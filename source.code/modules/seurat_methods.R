#' integratedData

#' Integrated single cell RNA-seq data.
#'
#' @param merged.obj Seurat object containing sample identities for each cell in the metadata.
#' @return Integrated Seurat object
#' @export

integratedData <- function(merged.obj, split.by = "orig.ident", config.dir = "./configs", integed = T, regress = T, assay = "RNA", npcs = 30) {
    cc.genes <- readLines(con = file.path(config.dir, "regev_lab_cell_cycle_genes.txt"))
    s.genes <- cc.genes[1:43]
    g2m.genes <- cc.genes[44:97]
    require(future)
    options(future.globals.maxSize = 500000 * 1024^2, future.seed = TRUE)
    plan("multiprocess", workers = 10)

    if (integed) {
        obj.list <- SplitObject(merged.obj, split.by = split.by)
        for (i in 1:length(obj.list)) {
            obj.list[[i]] <- NormalizeData(obj.list[[i]], verbose = FALSE)
            obj.list[[i]] <- FindVariableFeatures(obj.list[[i]], selection.method = "vst", nfeatures = 2000, verbose = FALSE)
            var.genes <- VariableFeatures(obj.list[[i]])
            var.genes <- var.genes[!(grepl("IGKV", var.genes))]
            var.genes <- var.genes[!(grepl("IGLV", var.genes))]
            var.genes <- var.genes[!(grepl("IGHV", var.genes))]
            var.genes <- var.genes[!(grepl("TRAV", var.genes))]
            var.genes <- var.genes[!(grepl("TRBV", var.genes))]
            var.genes <- var.genes[!(grepl("TRDV", var.genes))]
            var.genes <- var.genes[!(grepl("TRGV", var.genes))]
            var.genes <- var.genes[!(grepl("^MT-", var.genes))]
            var.genes <- var.genes[!(grepl("^RP[SL]", var.genes))]
            var.genes <- var.genes[!(var.genes %in% cc.genes)]
            VariableFeatures(obj.list[[i]]) <- var.genes
        }

        # options(future.globals.maxSize = 10000 * 1024^2)
        anchors <- FindIntegrationAnchors(object.list = obj.list, dims = 1:npcs)
        obj.integrated <- IntegrateData(anchorset = anchors, dims = 1:npcs)
    } else {
        obj.integrated <- merged.obj
    }

    DefaultAssay(obj.integrated) <- assay
    s.genes.1 <- intersect(s.genes, rownames(obj.integrated))
    g2m.genes.1 <- intersect(g2m.genes, rownames(obj.integrated))
    obj.integrated <- CellCycleScoring(object = obj.integrated, s.features = s.genes.1, g2m.features = g2m.genes.1, set.ident = FALSE, seed = 1234)
    obj.integrated[["percent.mt"]] <- PercentageFeatureSet(object = obj.integrated, pattern = "^MT-")
    obj.integrated[["percent.ribo"]] <- PercentageFeatureSet(object = obj.integrated, pattern = "^RP[SL]")

    if (integed) DefaultAssay(obj.integrated) <- "integrated"
    cc.xx <- ifelse(DefaultAssay(obj.integrated) == "Spatial", "nCount_Spatial", "nCount_RNA")
    if (regress) {
        obj.integrated <- ScaleData(object = obj.integrated, vars.to.regress = c("S.Score", "G2M.Score", cc.xx, "percent.mt", "percent.ribo"), verbose = FALSE)
    } else {
        obj.integrated <- ScaleData(object = obj.integrated)
    }
}

#' validateMarkers

#' Validate our marker genes based on the markers provided by science paper.
#'
#' @param markers Marker genes generated by FindAllMarkers.
#' @param top.n Top N genes used to analyze, default: 50.
#' @param label Label name for output figure, default: NULL.
#' @param out.figs.dir Output directory for saving figuure, default: current dir.
#' @return NULL
#' @export

validateMarkers <- function(markers, top.n = 50, label = "", out.figs.dir = "./") {
    top50.markers <- markers %>%
        group_by(cluster) %>%
        top_n(n = top.n, wt = avg_log2FC)
    science.markers <- read.table("../4.extdata/science_thymus_markers.csv", sep = ",", header = T)
    our.markers <- lapply(unique(markers$cluster), function(x) subset(top50.markers, cluster == x)$gene)
    names(our.markers) <- unique(markers$cluster)
    text.labels <- ovp.markers <- lapply(our.markers, function(x) {
        cnts <- apply(science.markers, 2, function(y) {
            intersect(x, y) %>% length()
        })
    }) %>%
        as.data.frame() %>%
        t()

    breaks.list <- seq(0, max(ovp.markers), by = 1)
    text.labels[text.labels == 0] <- ""
    col <- colorRampPalette(c("white", "red"))(length(breaks.list))
    pheatmap::pheatmap(
        ovp.markers,
        cluster_cols = F,
        cluster_rows = F,
        display_numbers = text.labels,
        color = col,
        fontsize_number = 12,
        main = "Overlap of marker genes: Ours vs. Park et al. (Scicence, 2020)",
        width = 16,
        height = 6,
        filename = sprintf("%s/%s.our.overlap.science.markers.Heatmap.pdf", out.figs.dir, label)
    )

    ovp.markers <- lapply(our.markers, function(x) {
        cnts <- apply(science.markers, 2, function(y) {
            intersect(x, y)
        })
    })
    ovp.markers <- lapply(ovp.markers, function(x) {
        idx <- lapply(x, length) %>% {
            which(. != 0)
        }
        x[idx]
    })
    return(ovp.markers)
}

#' findAllMarkersPatched

#' Find all markers and save to the output directory.
#'
#' @param obj Seurat object for finding marker genes.
#' @param marker.rds The file name of the markers, which is a RDS format file.
#' @param re.run Re-run FindAllMarkers to identify markers, default: FALSE.
#' @param Prefix Prefix name of result files, default: NULL.
#' @param out.data.dir Output directory for saving marker genes, default: current dir.
#' @return Identified marker genes using FindAllMarkers
#' @export

findAllMarkersPatched <- function(obj, marker.rds, re.run = FALSE, prefix = NULL, out.data.dir = "./", ...) {
    if (!file.exists(file.path(out.data.dir, marker.rds)) || re.run) {
        require(future)
        options(future.globals.maxSize = 40000 * 1024^2)
        plan("multiprocess", workers = 40)
        de.markers <- FindAllMarkers(obj, only.pos = TRUE, logfc.threshold = 0.25, ...)
        write.table(de.markers, file.path(out.data.dir, sprintf("%s.de.markers.xls", prefix)), sep = "\t", quote = F, row.names = F)
        top20 <- de.markers %>%
            group_by(cluster) %>%
            top_n(n = 20, wt = avg_log2FC)
        write.table(top20, file.path(out.data.dir, sprintf("%s.top20.de.markers.xls", prefix)), sep = "\t", quote = F, row.names = F)
        saveRDS(de.markers, file = file.path(out.data.dir, marker.rds))
    } else {
        de.markers <- readRDS(file.path(out.data.dir, marker.rds))
    }
    return(de.markers)
}

#' lrModel

#' Logistic regression model to adjust annotated cell types.
#'
#' @param X.train.sub Training data, Seurat object.
#' @param y.train.sub A vector of traning labels.
#' @param X.test Testing data, Seurat object.
#' @param y.test A vector of testing labels.
#' @param prefix Prefix name of AUC figures, default: NULL.
#' @param out.figs.dir Directory for saving AUC plots, default: ./.
#' @return Trained logistic regression model.
#' @export

lrModel <- function(X.train.sub, y.train.sub, X.test, y.test, prefix = NULL, out.figs.dir = "./", wt = 6, ht = 6, color = NULL, linewidth = 1.5) {
    sklearn <- import("sklearn.linear_model")
    lr <- sklearn$LogisticRegression(max_iter = 100000, penalty = "l2", C = 0.2)
    lr$fit(X.train.sub %>% GetAssayData(.) %>% t(), y.train.sub)
    y.prob <- lr$predict_proba(X.test %>% GetAssayData(.) %>% t())
    pred.res <- lr$predict(X.test %>% GetAssayData(.) %>% t())

    require(pROC)
    plot.lst <- lapply(lr$classes_, function(cell) {
        labels <- ifelse(y.test == cell, cell, "N")
        probs <- y.prob[, which(lr$classes_ == cell)]
        return(roc(labels, probs))
    })
    names(plot.lst) <- paste0(lr$classes_, " (AUC = ", lapply(plot.lst, function(oo) round(oo$auc[1], 3) %>% as.vector()), ")")
    if (!is.null(color)) {
        idxes <- match(lr$classes_, names(color))
        color <- color[lr$classes_] %>% `names<-`(names(plot.lst))
        color.new <- color[order(idxes)]
        plot.lst <- plot.lst[names(color.new)]
    }
    gp <- ggroc(plot.lst) + theme_classic(base_size = 16) + guides(color = guide_legend(title = "CellType")) + theme(legend.position = c(0.8, 0.2))
    if (!is.null(color)) {
        gp <- gp + scale_color_manual(values = color)
    }
    gp <- gp + geom_line(size = linewidth)
    ggsave(file.path(out.figs.dir, sprintf("%s.auc.curve.pdf", prefix)), width = wt, height = ht)
    return(lr)
}

#' deconvByDWLS

#' Deconvolution bulk samples based on DWLS method.
#'
#' @param obj.sub Seurat object.
#' @param sig.mat Reference profile.
#' @param tar.col Target column name in the metadata file need to be deconvoluted.
#' @param cell.order Cell order.
#' @param prefix Prefix name of output figures, default: NULL.
#' @param out.figs.dir Output figures dir, default: ./.
#' @return Estimate proportions.
#' @export

deconvByDWLS <- function(obj.sub, sig.mat, tar.col, cell.order, prefix = NULL, out.figs.dir = "./", ...) {
    source("modules/Deconvolution_functions.R")
    cell.order <- cell.order[which(cell.order %in% (obj.sub@meta.data[, tar.col] %>% unique()))]
    bulk.exprs <- AverageExpression(obj.sub, group.by = tar.col)$RNA %>% .[, cell.order]
    cc <- intersect(rownames(bulk.exprs), rownames(sig.mat))

    res.deconv <- sapply(colnames(bulk.exprs), function(x) {
        res.dwls <- solveDampenedWLS(sig.mat %>% as.matrix() %>% .[cc, ], log(1 + bulk.exprs[cc, x]))
    }) %>% data.frame()

    colnames(res.deconv) <- cell.order
    pheatmap::pheatmap(
        t(res.deconv),
        cluster_rows = F,
        cluster_cols = F,
        # main = sprintf('Cellular fractions of %s cells.', label),
        filename = sprintf("%s/%s.Heatmap.pdf", out.figs.dir, prefix),
        ...
    )
    res.deconv
}

#' updateAnnoRes

#'
#' @param anno.res A vector of annotated results.
#' @param obj.merged Seurat object.
#' @param from.anno Raw annotation.
#' @param from.meta Raw meta data column name.
#' @param to.anno Update annotation.
#' @param to.meta Update meta data column name.
#' @return Updated Seurat object.
#' @export

updateAnnoRes <- function(anno.res, obj.merged, from.meta, to.meta) {
    obj.merged <- AddMetaData(obj.merged, metadata = obj.merged@meta.data[, from.meta], col.name = to.meta)
    if (sum(names(anno.res) %in% colnames(obj.merged)) != length(anno.res)) stop("ERROR")
    obj.merged@meta.data[names(anno.res), to.meta] <- as.vector(anno.res)
    # Idents(obj.merged) <- factor(obj.merged@meta.data[, to.meta])
    return(obj.merged)
}

#' trainLRmodel

#' Traning logistic regression model for predicting cell types.
#' @param obj Seurat object.
#' @param class.labs Specified classes which need to be tranined.
#' @param sample.size Sample cells if the count of class type more is too larger, default: 2000.
#' @param prefix Prefix name of auc figure.
#' @param out.figs.dir Output directory, default: ./.

trainLRmodel <- function(obj, class.labs, sample.size = 2000, prefix = NULL, out.figs.dir = "./", ...) {
    set.seed(123456)
    obj.sub <- subset(obj, idents = class.labs)
    sample.res <- sample.split(Idents(obj.sub) %>% as.vector(), SplitRatio = 0.8)
    X.train <- obj.sub[, sample.res == TRUE]
    y.train <- Idents(obj.sub) %>%
        as.vector() %>%
        .[sample.res == TRUE]
    X.test <- obj.sub[, sample.res == FALSE]
    y.test <- Idents(obj.sub) %>%
        as.vector() %>%
        .[sample.res == FALSE]

    new.idxes <- lapply(class.labs, function(lab) {
        if (sum(y.train == lab) > sample.size) {
            idxes <- sample(which(y.train == lab), sample.size, replace = FALSE)
        } else {
            idxes <- which(y.train == lab)
        }
        return(idxes)
    }) %>% unlist()
    y.train.sub <- y.train[new.idxes]
    X.train.sub <- X.train[, new.idxes]
    lr.model <- lrModel(X.train.sub, y.train.sub, X.test, y.test, prefix = prefix, out.figs.dir = out.figs.dir, ...)
    return(lr.model)
}

#' transitValidate

#' Validation of transtional cell types from raw to predicted.
#' @param obj Seurat object.
#' @param SIG.REF Reference profile for deconvolution.
#' @param from.col Raw meta data column name.
#' @param to.col Predicted meta data column name.
#' @param ident.order Label orders.
#' @return NULL
#' @export

transitValidate <- function(obj, SIG.REF, from.col, to.col, ident.order, anno.title = NULL, w1 = 6, h1 = 6, w2 = 12, h2 = 4) {
    cells.differ <- cbind.data.frame(Raw = obj@meta.data[, from.col] %>% as.vector(), Update = obj@meta.data[, to.col])
    cells.differ <- cells.differ[cells.differ$Raw != cells.differ$Update, ]
    obj.sub <- subset(obj, cells = colnames(obj)[rownames(cells.differ) %>% as.integer()])

    beforeVsAfterDiffer(
        obj.sub,
        c(from.col, to.col),
        ident.order,
        anno.title,
        out.figs.dir,
        width = w1,
        height = h1
    )

    deconvByDWLS(
        obj.sub,
        SIG.REF,
        from.col,
        ident.order,
        sprintf("%s.cellular.frac", from.col),
        out.figs.dir,
        width = w2,
        height = h2
    )

    deconvByDWLS(
        obj.sub,
        SIG.REF,
        to.col,
        ident.order,
        sprintf("%s.cellular.frac", to.col),
        out.figs.dir,
        width = w2,
        height = h2
    )
}

#' markerValidate

#' Validation of marker genes.
#' @param obj Seurat object.
#' @param de.markers Identified markers by FindAllMarkers.
#' @param meta.col Column name of metadata.
#' @param label Label of output file.
#' @param out.figs.dir Output directory.
#' @return Overlap marker genes.
#' @export

markerValidate <- function(obj, de.markers, SIG.REF, meta.col, label, out.figs.dir = "./", top = 10, top2 = 20, ...) {
    ovp.markers <- validateMarkers(de.markers, label = label, out.figs.dir = out.figs.dir, top.n = top2)
    top10 <- de.markers %>%
        group_by(cluster) %>%
        top_n(n = top, wt = avg_log2FC)
    DotPlotCustom(obj, top10$gene %>% unique(), flip = FALSE) + theme(axis.text.x = element_text(face = "italic"))
    ggsave(file.path(out.figs.dir, sprintf("%s.top10.Bubble.pdf", label)), ...)

    deconvByDWLS(
        obj,
        SIG.REF,
        meta.col,
        levels(obj),
        sprintf("%s.cellular.frac", label),
        out.figs.dir,
        width = 12,
        height = 4
    )
    return(ovp.markers)
}

#' removeCellsByLR

#' Iterate remove other cell types in the reference cells.
#' @param obj.model Seurat object.
#' @param pred.obj Seurat object.
#' @param ref.cell Reference cell type.
#' @param ident.cells Other cell types need to be check.
#' @param prefix Prefix name of output file.
#' @param out.figs.dir Output directory for saving figures.
#' @return A vector of predicted cell types.
#' @export

removeCellsByLR <- function(obj.model, pred.obj, ref.cell, ident.cells, prefix, out.figs.dir) {
    ident.cells <- setdiff(ident.cells, ref.cell)
    pred.res <- lapply(ident.cells, function(cell) {
        lr.model <- trainLRmodel(obj.model, c(ref.cell, cell), sample.size = 2000, prefix = sprintf("%s.%s_vs_%s", prefix, ref.cell, cell), out.figs.dir = out.figs.dir)
        pred.res <- lr.model$predict(pred.obj %>% GetAssayData(.) %>% t()) %>% `names<-`(colnames(pred.obj))
    }) %>% unlist(.)
    return(pred.res)
}

#' assignBatches

#' Assign batches to the samples.
#' @param obj Seurat object.
#' @param cut.res Batches drived from hclust method.
#' @param cut.num Specify cut number.
#' @return Seurat object
#' @export

assignBatches <- function(obj, cut.res, cut.num) {
    idxes <- cutree(cut.res$tree_col, k = cut.num)
    idxes.names <- gsub("\\:.*", "", names(idxes))
    names(idxes) <- idxes.names
    obj@meta.data$Batch <- obj@meta.data$orig.ident %>% as.vector()
    for (idx in idxes.names) {
        obj@meta.data$Batch[obj@meta.data$Batch == idx] <- idxes[idx]
    }
    return(obj)
}

#' runReClustering
#' Re-run clustering using seurat pipeline.
#' @param obj Seurat object.
#' @param split.by Split data batch column in the metadata, default: Batch.
#' @param integed Integrated data or not, default: TRUE.
#' @param findVar Find variable features or not, default: FALSE.
#' @param res Specify resolution for clustering, default: 0.5.
#' @return Seurat

runReClustering <- function(obj, split.by = "Batch", integed = T, res = 0.5, findVar = F, nxx = 30, clsut = T, ...) {
    set.seed(1234)
    if (clsut) obj <- integratedData(obj, split.by = split.by, integed = integed, ...)
    if (findVar) obj <- FindVariableFeatures(obj)
    obj <- RunPCA(obj, seed.use = 8123456, npcs = 50)
    obj <- RunUMAP(obj, reduction = "pca", dims = 1:nxx, seed.use = 8123456)
    obj <- FindNeighbors(obj, reduction = "pca", dims = 1:nxx)
    obj <- FindClusters(obj, resolution = res, random.seed = 8123456)
    return(obj)
}

#' percentBarPatched

#' Plot percentage bars for patients and age status.
#' @param obj Seurat object.
#' @param meta.col Specify column name in seurat meta.data.
#' @param cols Specify columns of each subset, default: NULL.
#' @param level.order Order of the cell types, default: NULL.
#' @param prefix Prefix name of output figures, default: NULL.
#' @param out.figs.dir Output directory for saving figurres, default: ./.

percentBarPatched <- function(obj, meta.col, cols = NULL, level.order = NULL, prefix = NULL, out.figs.dir = "./") {
    orig.ident <- paste0(obj@meta.data[, "orig.ident"], ":", obj@meta.data[, "Age"])
    td.1 <- as.data.frame(prop.table(table(obj@meta.data[, meta.col], orig.ident), margin = 2))
    td.2 <- as.data.frame(prop.table(table(obj@meta.data[, meta.col], obj@meta.data[, "AgeStatus"]), margin = 2))
    if (!is.null(level.order)) {
        td.1[, 1] <- factor(td.1[, 1], levels = level.order)
        td.2[, 1] <- factor(td.2[, 1], levels = level.order)
    }
    gp1 <- percntStackBarplot(td.1, cols)
    gp2 <- percntStackBarplot(td.2, cols)
    ggarrange(gp1, gp2, ncol = 2)
    ggsave(file.path(out.figs.dir, sprintf(prefix, ".pdf")), width = 10, height = 8)
    return(list(gp1 = gp1, gp2 = gp2))
}

#' runHarmony

#' Run harmony for singel cell clustersing.
#' @param obj.integrated Annotated seurat object.
#' @param de.markers Differential expressed genes generated by FindAllMarkers.
#' @param top.n Number of top expressed genes used for PCA, default: 50.
#' @param config.dir Diectory of configure files, default: ./configs.
#' @param regress Regress out technical and biological effects or not, default: TRUE.
#' @return Seurat object.
#' @export

runHarmony <- function(obj.integrated, de.markers = NULL, top.n = 50, config.dir = "./configs", regress = T) {
    if (!is.null(de.markers)) {
          var.genes <- de.markers %>%
              group_by(cluster) %>%
              top_n(n = top.n, wt = avg_log2FC) %>%
              .[, "gene"] %>%
              unlist() %>%
              as.vector()
      }
    DefaultAssay(obj.integrated) <- "RNA"
    cc.genes <- readLines(con = file.path(config.dir, "regev_lab_cell_cycle_genes.txt"))
    s.genes <- cc.genes[1:43]
    g2m.genes <- cc.genes[44:97]

    s.genes.1 <- intersect(s.genes, rownames(obj.integrated@assays$RNA@data))
    g2m.genes.1 <- intersect(g2m.genes, rownames(obj.integrated@assays$RNA@data))
    obj.integrated <- CellCycleScoring(object = obj.integrated, s.features = s.genes.1, g2m.features = g2m.genes.1, set.ident = FALSE)
    obj.integrated[["percent.mt"]] <- PercentageFeatureSet(object = obj.integrated, pattern = "^MT-")
    obj.integrated[["percent.ribo"]] <- PercentageFeatureSet(object = obj.integrated, pattern = "^RP[SL]")

    require(future)
    options(future.globals.maxSize = 50000 * 1024^2)
    plan("multiprocess", workers = 20)
    obj.integrated <- FindVariableFeatures(obj.integrated)
    if (!is.null(de.markers)) VariableFeatures(obj.integrated) <- var.genes
    if (regress) {
        obj.integrated <- ScaleData(
            object = obj.integrated,
            vars.to.regress = c("S.Score", "G2M.Score", "nCount_RNA", "percent.mt", "percent.ribo", "orig.ident"),
            verbose = FALSE
        )
    } else {
        obj.integrated <- ScaleData(object = obj.integrated)
    }

    require(harmony)
    obj.integrated <- RunPCA(obj.integrated, seed.use = 8123456, npcs = 50) %>% RunHarmony("orig.ident", plot_convergence = TRUE)
    obj.integrated <- RunUMAP(obj.integrated, reduction = "harmony", dims = 1:30, seed.use = 8123456)
    return(obj.integrated)
}

#' removeDoublets

#' Remove doublets using DoubletFinder tool.
#' @param obj Seurat object.
#' @return Singlet cells
#' @export

removeDoublets <- function(obj) {
    sweep.res.list <- paramSweep_v3(obj, PCs = obj@commands$FindNeighbors.RNA.pca$dims)
    weep.res.list <- paramSweep_v3(obj, PCs = obj@commands$FindNeighbors.RNA.pca$dims)
    sweep.stats <- summarizeSweep(sweep.res.list, GT = FALSE)
    bcmvn <- find.pK(sweep.stats)
    pK <- bcmvn[which(max(bcmvn$BCmetric) == bcmvn$BCmetric), 2] %>%
        as.character() %>%
        as.numeric()

    ## ------------------------1). Homotypic Doublet Proportion Estimate ------------------------
    homotypic.prop <- modelHomotypic(obj@active.ident)
    nExp_poi <- round(0.05 * length(colnames(obj)))
    nExp_poi.adj <- round(nExp_poi * (1 - homotypic.prop))

    ## ------------------------2). Run DoubletFinder with varying classification stringencies ---
    obj <- doubletFinder_v3(obj, PCs = obj@commands$FindNeighbors.RNA.pca$dims, pN = 0.25, pK = pK, nExp = nExp_poi, reuse.pANN = FALSE)
    obj <- doubletFinder_v3(obj, PCs = obj@commands$FindNeighbors.RNA.pca$dims, pN = 0.25, pK = pK, nExp = nExp_poi.adj, reuse.pANN = grep("pANN", names(obj@meta.data), value = T))

    ## ------------------------3). Plot results ---------------------------------------------------
    high_of_low <- (obj@meta.data[, grep("^DF\\.classifications", names(obj@meta.data), value = T)] == "Singlet") + 0
    obj@meta.data[high_of_low[, 1] + high_of_low[, 2] == 2, "DF_hi.lo"] <- "Singlet"
    obj@meta.data[high_of_low[, 1] + high_of_low[, 2] == 1, "DF_hi.lo"] <- "Doublet_lo"
    obj@meta.data[high_of_low[, 1] + high_of_low[, 2] == 0, "DF_hi.lo"] <- "Doublet_hi"
    return(obj@meta.data[grepl(obj$DF_hi.lo, pattern = "Singlet"), ] %>% row.names())
}
